#!/bin/bash

# Copyright (C) 2016 Pavel Tisnovsky <ptisnovs@redhat.com>

# This program is  free software:  you can redistribute it and/or modify it
# under  the terms  of the  GNU General Public License  as published by the
# Free Software Foundation, version 3 of the License.
#
# This program  is  distributed  in the hope  that it will  be useful,  but
# WITHOUT  ANY WARRANTY;  without  even the implied  warranty of MERCHANTA-
# BILITY  or  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the  GNU General Public License  along
# with this program. If not, see <http://www.gnu.org/licenses/>.


# Common configuration options
EMENDER_PAGE=http://jenkinscat.gsslab.pnq.redhat.com:6502/emender
EMENDER_CHANGELOG=https://mojo.redhat.com/docs/DOC-1083484
PATH_TO_TESTS=~/emender-rhel/test/

# Should the format be read from the metadata.ini or should we read content of directory
CHECK_METADATA_INI_FIRST=0

# Whether to use colorized output
USE_COLOR_LOG=0



# Terminal color codes
# - can be disabled by the parameter USE_COLOR_LOG
BLACK="[0;30m"
RED="[0;31m"
GREEN="[0;32m"
BLUE="[0;34m"
MAGENTA="[0;35m"
CYAN="[0;36m"
RESET="[0m"

if [ $USE_COLOR_LOG -eq 0 ]
then
    BLACK=""
    RED=""
    GREEN=""
    BLUE=""
    MAGENTA=""
    CYAN=""
    RESET=""
fi



#
# Setup function
#
function setup {
    export TERM=linux
    export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk/
}



#
# If the content directory is not set by the Jenkins, set it to the default value.
#
function update_content_directory {
    if [ -z "$MD_CONTENT_DIRECTORY" ]
    then
        MD_CONTENT_DIRECTORY="./"
    fi
}



#
# Try to read book format from the metadata.ini file. If the file does not exist or format
# (markup) is not specified, let's assume the format is 'docbook'.
#
function read_book_format {
    if [[ $CHECK_METADATA_INI_FIRST -eq 1 ]]
    then
        if [ -f "$1/metadata.ini" ]
        then
            markup=`sed -n 's/markup\s*=\s*\([a-zA-Z]*\)/\1/p' $1/metadata.ini 2> /dev/null`
            if [ ! -z $markup ]
            then
                BOOK_FORMAT=$markup
            else
                echo "Can not read $1/metadata.ini, please check repository structure"
                BOOK_FORMAT="docbook"
            fi
        else
            echo "Can not read the following file: find $1/metadata.ini, fallbacking..."
            if [ -f "$1/master.adoc" ]
            then
                echo "Found master.adoc, this guide is written in AsciiDoc"
                BOOK_FORMAT="asciidoc"
            elif [ -f "$1/publican.cfg" ]
            then
                echo "Found publican.cfg, this guide is written in DocBook"
                BOOK_FORMAT="docbook"
            else
                echo "Can't decide the format..."
                BOOK_FORMAT="unknown"
            fi
        fi
    else
        echo "Skipped checking $1/metadata.ini..."
        if [ -f "$1/master.adoc" ]
        then
            echo "Found master.adoc, this guide is written in AsciiDoc"
            BOOK_FORMAT="asciidoc"
        elif [ -f "$1/publican.cfg" ]
        then
            echo "Found publican.cfg, this guide is written in DocBook"
            BOOK_FORMAT="docbook"
        else
            echo "Can't decide the format..."
            BOOK_FORMAT="unknown"
        fi
    fi
}



#
# Check if the specified file exists. If not, error is reported and script ends with exit code=1
#
function check_file {
    if [ -f $1 ]
    then
        echo "file $1 present"
    else
        echo "file $1 can not be found"
        exit 1
    fi
}



#
# Check if the specified directory exists. If not, error is reported and script ends with exit code=1
#
function check_directory {
    if [ -d $1 ]
    then
        echo "directory $1 present"
    else
        echo "directory $1 can not be found"
        exit 1
    fi
}



#
# Check the basic directory structure of the tested guide.
#
function check_basic_directory_structure {
    echo "Checking directory structure"
    check_file publican.cfg
    check_directory en-US
    #check_file en-US/Book_Info.xml # does not have to exist, primary file can be specified in publican.cfg
}



#
# Print information before the Emender is started
#
function print_info {
    echo "*** Emender ***"
    echo "Job name:          ${JOB_NAME}"
    echo "Job URL:           ${JOB_URL}"
    echo "Content directory: ${MD_CONTENT_DIRECTORY}"
    echo "Other arguments:   $@"
    echo "Book format:       $BOOK_FORMAT"
}



#
# Convert AsciiBook book into Publican (DocBook) directory structure.
#
function convert_asciidoc_to_docbook {
    echo "Converting Asciidoc->DocBook"
    # cleanup
    rm -rf en-US
    rm -f publican.cfg

    pushd $1 > /dev/null

    # convert the master.adoc file to DocBook 4.5 format
    asciidoctor -d book -b docbook45 -a nolang -r asciidoctor-diagram "$2.adoc"

    # prepare stub for Publican book
    publican create --name "$2"

    # try to convert special character to proper apostrophe
    sed -i.backup "s/&#8217;/'/" "$2.xml"

    # move the master.xml to the right place
    mv "$2.xml" "$2/en-US/$2.xml"

    # put the resulting DocBook into the common place
    echo "Moving document tree into the following directory $3"
    mv "$2/publican.cfg" "$3/"
    mv "$2/en-US" "$3"

    # cleanup the directory created by "publican create"
    rm -rf "$2"

    popd > /dev/null
}



function update_docbook_repo {
    if [ "$1" == "./" ]
    then
        echo "Content is stored in ./ (book model, not library model)"
    else
        echo "Updating docbook repository"
        # cleanup
        rm -rf en-US
        rm -f publican.cfg
        cp -r "$1/en-US" ./
        cp "$1/publican.cfg" ./
    fi
}



#
# Add common content to the tested book
#
function add_common_content {
    mkdir -p en-US/Common_Content
    cp ~/emender-rhel/test/Legal_Notice.xml en-US/Common_Content
    cp ~/emender-rhel/test/Conventions.xml en-US/Common_Content
    cp ~/emender-rhel/test/Feedback.xml en-US/Common_Content
    cp ~/emender-rhel/test/Program_Listing.xml en-US/Common_Content
}



setup
update_content_directory
read_book_format $MD_CONTENT_DIRECTORY
print_info $@

if [ $BOOK_FORMAT == "asciidoc" ]
then
    convert_asciidoc_to_docbook "${MD_CONTENT_DIRECTORY}" master "`pwd`"
    add_common_content
fi

if [ $BOOK_FORMAT == "docbook" ]
then
    update_docbook_repo "$MD_CONTENT_DIRECTORY"
fi

check_basic_directory_structure


rm -f results.*

#TESTS=TestWritingStyle.lua
#TESTS=CustomerPortalRequirements.lua
#TESTS=TestPackages.lua
#TESTS=TestLinks.lua

if [ $BOOK_FORMAT == "docbook" ]
then
    TESTS=${PATH_TO_TESTS}/*.lua
elif [ $BOOK_FORMAT == "asciidoc" ]
then
    TESTS="${PATH_TO_TESTS}/CustomerPortalRequirements.lua ${PATH_TO_TESTS}/GuideStatistic.lua ${PATH_TO_TESTS}/TestLinks.lua ${PATH_TO_TESTS}/TestWritingStyle.lua"
else
    TESTS=${PATH_TO_TESTS}/TestLinks.lua
fi

echo "Tests to run: ${TESTS}"

emend -f Emender_page -c -t Release -t WritingStyle ${TESTS} -o results.xml -o results.junit -o results.txt -o results.html -o results.json -o results.summary -o results.message -N "${JOB_NAME}" -j "${JOB_URL}" -C ChangeLog_page $@

RESULT=$?
echo "Result code: ${RESULT}"
echo "Test result summary: $(cat results.message)"
cp results.junit junit.xml
#exit ${RESULT}

